<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Uplink Azure Migration | ojcodes</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/projects.css" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Lobster&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <!-- Header -->
    <header class="header">
      <div class="container">
        <div class="logo">ojcodes</div>
        <nav class="nav">
          <button class="hamburger" aria-label="Menu">
            <span></span>
            <span></span>
            <span></span>
          </button>
          <ul class="nav-links">
            <li><a href="/#home">Home</a></li>
            <li><a href="/#about">About</a></li>
            <li><a href="/#projects">Projects</a></li>
            <li><a href="/#personal">Personal</a></li>
            <li><a href="/#blog">Blog</a></li>
            <li><a href="/#contact">Contact</a></li>
          </ul>
        </nav>
      </div>
    </header>

    <main>
      <section class="project-header">
        <div class="container">
          <h1>UpLink Azure Migration</h1>
          <p>
            Built infrastructure, CI/CD pipelines, and dashboards to migrate
            UpLink from AWS into Azure
          </p>
        </div>
      </section>

      <section class="project-content">
        <div class="container">
          <h2>Project Overview</h2>
          <p>
            The UpLink Azure Migration project was a comprehensive initiative to
            move the UpLink application, formerly hosted on AWS, into Microsoft
            Azure.
          </p>

          <p>The primary goals were to:</p>

          <ul>
            <li>
              Standardize all infrastructure as code for consistency and
              repeatability
            </li>

            <li>
              Establish automated CI/CD pipelines for both frontend and backend
              components
            </li>

            <li>Centralize observability through custom dashboards</li>

            <li>Reduce operational toil and improve deployment velocity</li>
          </ul>
          <p>
            By leveraging Azure’s native services, we enabled the team to deploy
            changes faster, gain end-to-end visibility, and operate within a
            single cloud environment.
          </p>

          <div class="tech-stack">
            <span>Terraform</span>
            <span>Azure CLI</span>
            <span>Azure Container Apps</span>
            <span>Azure Key Vault</span>
            <span>Service Bus</span>
            <span>Log Analytics</span>
            <span>Github Actions</span>
            <span>OpenAI</span>
          </div>

          <h2>Key Features</h2>
          <ul>
            <li>
              Modular Terraform Modules: Network, compute, storage, and RBAC
              components packaged for reuse
            </li>
            <li>
              Automated Pipelines: End-to-end GitHub Action pipelines for build,
              test, and deploy of frontend and backend
            </li>
            <li>
              Live Dashboards: Custom Azure Monitor workbooks surfacing
              SLIs/SLOs for Container Apps, Document Intelligence, and OpenAI
              calls
            </li>
            <li>
              Secrets Management: Centralized secret injection via Key
              Vault-backed service connections
            </li>
          </ul>

          <h2>Implementation Details</h2>
          <p>
            We began by architecting a robust infrastructure foundation in
            Terraform, defining a landing zone complete with virtual networks,
            subnets, and network security groups. To promote consistency and
            reuse, we modularized key components, such as Container Apps
            environments and Azure Key Vault instances, and configured remote
            state storage in Azure Storage.
          </p>
          <p>
            Next, we crafted dedicated GitHub Action pipelines in Azure DevOps
            for both the React frontend and Python backend. Each pipeline
            orchestrates Terraform plan/apply tasks alongside build, test, and
            deploy stages. We also layered in manual approval gates for
            production deployments to enforce compliance and reduce risk.
          </p>
          <p>
            For end-to-end visibility, we instrumented our microservices with
            the Application Insights SDK, enabling custom events and metrics
            collection. Log Analytics queries track error rates, request
            latency, and resource utilization, which we surface through Azure
            Dashboards featuring real-time charts and drill-down logs.
          </p>
          <p>
            Security was baked in at every layer: all secrets live in Azure Key
            Vault and are accessed via managed identities to maintain
            least-privilege access. Role-based access controls on resource
            groups and pipeline service principals ensure only authorized
            personnel can trigger deployments or view sensitive data.
          </p>
          <p>
            Finally, the new Azure environment was deployed in parallel with
            AWS, and new DNS records and urls were provisioned after automated
            integration tests validated feature parity. When the migration is
            successfully completed, we decommissioned AWS resources to eliminate
            configuration drift and capture cost savings.
          </p>

          <h3>Challenges and Solutions</h3>
          <p>
            One of the biggest hurdles we faced was that none of the UpLink team
            had prior Azure experience. To bridge this gap, we enrolled in
            Microsoft’s Fast Track program, which paired us with Azure engineers
            for weekly coaching sessions. During these meetings we validated our
            landing-zone design, refined our Terraform modules, and gradually
            built confidence in key services like Container Apps, Service Bus,
            and Key Vault.
          </p>
          <p>
            Coordinating work between our SRE team in Amsterdam and the UpLink
            engineers on the U.S. East Coast introduced another layer of
            complexity. We overcame this by establishing a rotating “core hours”
            schedule that guaranteed at least three overlapping work hours each
            weekday, volunteered to work earlier than my scheduled time to meet
            with them while another SRE from the Amsterdam team volunteered to
            stay later,and by running asynchronous design reviews in shared
            Notion pages and Azure DevOps/GitHub pull requests to keep everyone
            aligned despite the time-zone gap.
          </p>
          <p>
            Working with the Azure Terraform provider proved challenging; early
            versions exhibited erratic behaviors and intermittent errors as we
            defined complex networking and RBAC modules. To address this, we
            contributed bug reports upstream, implemented retries and
            workarounds in our wrapper scripts, and locked our provider version
            until stability improvements were released. This ensured our
            Terraform runs became predictable and reliable.
          </p>

          <h2>Results</h2>
          <p>
            We will know the success metrics when the migration is completed.
            Our launch date is June 30th.
          </p>

          <a href="index.html#projects" class="back-link">← Back to Projects</a>
        </div>
      </section>
    </main>

    <!-- Footer -->
    <footer class="footer">
      <div class="container">
        <p>Made with ❤️ by ojcodes. © 2025 All Rights Reserved.</p>
      </div>
    </footer>

    <script src="/js/main.js"></script>
  </body>
</html>
